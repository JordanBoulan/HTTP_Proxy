Jordan Boulanger, Morgan Weaver, Ellery Baines
Class: 5510, Computer Networks
Project 2: Group Project - Implementing a Simple HTTP Web Proxy: Part 1
Date: 10/29/2017
Files: proxy.cpp (no header file), makefile, README.txt

This program is comprised of 3 files; README.txt, proxy.cpp, and a makefile. 
Usage: 
Run 'make default' to create the a proxy executable.
use: ./proxy [port]
to run the proxy program listening on the specified port

Program process:

1. The program creates a proxy server that listens for incoming TCP connections on a disgnated socket. 

2. The server waits for incoming client connections. 

3. The server will create a child process in order to handle new incoming connections.

4. The proxy server takes an ABSOLUTE HTTP GET request, with the format:
	GET http://www.url.com/relative_path HTTP/1.0 [header1:values] [header2:values]...

5. The proxy server parses the request, returning an error to the client if the request is malformatted or if the request contains an unsupported request type.

6. The proxy server uses a telnet connection to the requested host server to fufill the client's request. 

7. Upon recieving reponse from the requested host server, the web proxy sends the response back to the client utilizing the TCP connection it previously stablished.

8. Finally, the server closes the TCP Connection.

Main Contributions:
Jordan: Connection with remote server & sending back response
Ellery: Parsing the request, checking the request, building new request string
Morgan: base connection code for telnet, remote etc, Fixed memory leak, removed compile warnings, code formatting

Design decisions:
Everything is in main. This makes it easy to follow the code flow, but makes it less readable and code is not reused. The code for creating a socket is used 3 times and could be put into a function. It was easier to debug (find which socket was failing etc) and make sure everything was working properly by leaving the code in main. In part two, we will need to open many more connections and will will most likely add modularity then for code readability and for the ability to reuse connection/socket opening code. Futhermore, it might make sense to put all the code in a class and include a header file, to make the code easier to read and understand. However, for this version we were focused purely on working functionality rather than asthetics.

